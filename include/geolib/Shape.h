#ifndef GEOLIB_SHAPE_H_
#define GEOLIB_SHAPE_H_

#include "datatypes.h"
#include "Mesh.h"
#include "Ray.h"
#include "Triangle.h"

namespace geo {

class Box;

/**
 * @brief A geometric description of a shape
 *
 * Defines a shape using a triangle mesh. The origin of the shape is not
 * necesarily in the centre of the shape.
 */
class Shape {

    friend class Importer;

public:

    Shape();

    virtual ~Shape();

    virtual Shape* clone() const;

    /**
     * @brief intersect: currently always throws a logic error
     * @param r
     * @param t0
     * @param t1
     * @param distance
     * @return true when the ray intersects the shape
     */
    virtual bool intersect(const Ray& r, float t0, float t1, double& distance) const;

    /**
     * @brief Determines whether the shape intersects a sphere with center p
     * @param p center of the sphere
     * @param radius radius of the sphere
     * @return True means the sphere intersects the shape
     */
    virtual bool intersect(const Vector3& p, const double radius) const;

    /**
     * @brief Determines whether a point p lies within the shape
     * @param p point to test
     * @return True means point p lies inside the shape
     */
    virtual bool contains(const Vector3& p) const;

    /**
     * @brief Calculate the maximum distance from the origin of the shape to any point of the shape
     * @return Maximum radius found.
     */
    virtual double getMaxRadius() const;

    /**
     * @brief Returns the smallest box which includes all mesh points. Box is not rotated, but matches
     * the axis of the Shape
     * @return geo::Box of the bounding box.
     */
    virtual Box getBoundingBox() const;

    /**
     * @brief return the mesh defining the shape
     * @return a constant reference to the mesh of the shape
     */
    virtual const Mesh& getMesh() const;

    /**
     * @brief set the Mesh
     * Any child classes should throw a std::logic_error in case the mesh should not be changed via #setMesh.
     * @param mesh mesh to set
     */
    virtual void setMesh(const Mesh& mesh);

    /**
     * @brief write, serialise the shape
     *
     * Serialisation must encode enough information to reconstruct a class object using the 'read' method
     * @param output: output stream
     * @return always true
     */
    virtual bool write(std::ostream& output) const;

    /**
     * @brief read serialised data from an input stream and create a shape
     * @param input: input stream, is expected to follow the format as generated by the 'write' method
     * @return shared pointer to the created shape
     */
    static ShapePtr read(std::istream& input);

    static const std::string TYPE;

    /**
     * @brief empty Test whether the shape(mesh) is empty.
     * @return True if the mesh is empty
     */
    inline virtual bool empty() const { return mesh_.empty(); }

protected:

    /**
     * @brief Should not be read or written to directly in general. Use #setMesh and #getMesh to write respectively read the mesh.
     * In a few exceptions, the mesh can be written direcly. Make sure that mesh keeps consistent with other member variables.
     */
    Mesh mesh_;

private:

    mutable bool  bounding_box_cache_valid_;    // keeps track if the cached values of the bounding box are valid
    mutable Vector3 bounding_box_min_cache_;    // cached value of the min corner of a bounding box
    mutable Vector3 bounding_box_max_cache_;    // cached value of the max corner of a bounding box
};

}


#endif
